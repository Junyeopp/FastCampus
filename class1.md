NOTE
=====

![capture](/img/cap1.PNG)

## Class1

- C++는 C를 포함하고 있어서 C++ 프로젝트 생성해서 확장자만 ```'.c'```로 바꿔주면 C로 사용 가능.

- 만들어진 프로그램을 실행가능한 형태로 내보내기 위해서는 솔루션 빌드를 해줘야함. 그러면 '.exe' 실행파일이 만들어지고 실행할 수 있음.

## Class2

- 정적변수로 선언된 변수는 기본적으로 0으로 값이 초기화됨.
- 정적변수는 ```main```함수 밖에 전역으로 설정된 변수를 말하는 것 같음.
- 음수표현법 :
    1. 부호 절대값 방식 : 가장 왼쪽 비트를 부호비트로 사용.
    2. 2의 보수 : 1의 보수 + 1.
- 실수표현법 : 부호, 지수, 유효숫자를 나누어서 표현.

## Class3

- ```scanf```를 warning없이 사용하기 위해서 ```#define _CRT_SECURE_NO_WARNINGS```를 적용한다.
- 입력받은 것을 한 자리씩 끊어서 받기 : ```scanf("%1d%1d%1d", &a, &b, &c");```

## Class4

- Escape Sequence 중 ```\b``` : 백 스페이스 넣기
- 삼항연산자 : 조건 ? 참일 때 실행 : 거짓일 때 실행
    - ex) ```(a==b) ? 100 : -100```
- 비트연산자 : ```>>``` 은 Shift 연산자로 2의 배수를 처리할 때 효과적

## Class5

- ```switch```문 : 조건에 부합하는 경우 아래쪽의 case도 모두 만족시킨다. 그래서 일반적인 경우 case문의 마지막에 ```break```를 넣어 특정부분만 실행하도록 한다.

## Class6

- 내부적으로 ```for``` 문과 ```while``` 문은 동일하게 작동함.

## Class8

- 배열 초기화 할 때 ```{0,}``` 로 쓰면 전체를 0으로 초기화 할  수 있다.
- ```INT_MIN``` : ```<limit.h>```에 있는 ```int```형 범위의 가장 작은 정수로 약 -20억.
- C언어에서 기본적으로 문자열 자료형을 제공하지않고 문자를 묶은 형태로 문자열을 표현.
- 문자열을 입력, 출력할 때는 ```%s``` 형식지정자를 사용.
- C++에서는 자체적으로 ```string``` 자료형을 제공.

## Class9

- 포인터는 메모리 주소를 저장하는 변수.
- 배열과 포인터는 내부적으로 동일하게 작동한다고 볼 수 있음.
- 배열을 선언한 이후에는 그 이름 자체가 포인터 변수와 동일함.

## Class10

- C언어에서 문자는 내부적으로 아스키 코드 구조를 따름.
- ```getchar()``` : ```<stdio.h>```에 있는 문자를 하나 입력받는 표준입력.
- <pre><code>int main(void) {
    int a;
    char c;
    scanf("%d", &a);
    printf("%d\n", a);
    scanf("%c", &c);
    printf("%c\n", c);
    return 0;
    }
</code></pre>
에서 ```100\n```을 입력하면 오류가 남. ```100```은 ```a```로 ```\n```은 ```b```로 입력됨.
- 이를 해결하기 위해서 첫번째 ```scanf```이후 남아있는 입력버퍼를 지워야 함.
<pre><code>int main(void) {
    int a;
    char c;
    scanf("%d", &a);
    printf("%d\n", a);
    int temp;
    while ((temp = getchar()) != EOF && temp != '\n'){}
    scanf("%c", &c);
    printf("%c\n", c);
    return 0;
    }</code></pre>

## Class11

- 문자열은 컴퓨터 메모리 구조상에서 마지막에 NULL 값을 포함. NULL은 문자열의 끝을 알리는 목적.
- <pre><code>int main(void){
    char *a = "Hello World";
    printf("%s\n", a);
    return 0;
    }</code></pre>
    - 문자열 형태로 포인터를 사용하면 포인터에 특정한 문자열의 주소를 넣음.
    - 이런 문자열을 문자열 리터럴이라고 하고 문자열을 읽기전용(수정불가)로 메모리에 넣음.
- ```scanf()``` : 공백을 만날 때까지 입력받음.
- ```gets()``` : 공백까지 포함하여 한 줄을 입력받음.
- ```gets_s()``` : 보안상의 이유로 사용. 버퍼의 크기를 지키도록 함.
- ```strstr()``` : 긴 문자열에서 짧은 문자열을 찾아 그 위치를 반환. 주소 값 자체를 반환함으로 단순히 출력하면 그 지점 이후 모든 문자열이 반환됨.

## Class12

- 일반적인 OS는 메모리 공간을 네 가지로 구분함.
    - 코드 영역 : 소스코드
    - 데이터 영역 : 전역변수, 정적변수
    - 힙 영역 : 동적할당변수
    - 스택 영역 : 지역변수, 매개변수
- 전역변수 : 프로그램이 실행될 때 메모리에 할당되어 프로그램이 종료되면 메모리에서 해제.
- 지역변수 : 특정 블록에서만 접근가능. 함수가 실핼될 때 메모리에 할당되어 함수가 종료되면 메모리에서 해제.
- 정적변수(Static Variable) : 특정 블록에서만 접근가능. 프로그램이 실행될 때 메모리에 할당되어 프로그램이 종료되면 메모리에서 해제.
- 레지스터변수(Register Variable) : 메인 메모리 대신 CPU 레지스터를 사용하는 변수. 실제로 레지스터에서 처리할지는 컴파일러가 결정.

## Class13

- 배열과 포인터의 차이점 : 포인터는 변수이며 배열의 이름은 상수이다. 그래서 다음과 같이 상수의 값을 변경할 수 없다.
    <pre><code>int a = 10;
    int b[10];
    b = &a;</code></pre>
- 포인터는 연산을 통해 자료형의 크기만큼 이동한다.

## Class14

- 스택에 선언된 변수는 따로 메모리 해제를 해주지 않아도 되지만, 동적으로 할당된 변수는 ```free()``` 로 메모리 해제를 해주어야 한다.
- 동적으로 문자열 처리하기 : ```<string.h>```에 있는 ```memset()```사용.

## Class15

- 함수 포인터 : C에서는 함수의 이름을 이용해 특정한 함수를 호출함. 함수의 이름은 메모리 주소를 반환. 특정한 함수의 반환 자료형을 지정하는 방식으로 선언할 수 있음.
    - 반환 자료형 (*이름)(매개변수) = 함수명;
    - <pre><code>int add(int a, int b) {
        return a + b;
        }
        int(*process(char* a))(int, int) {
            printf("%s\n", a);
            return add;
        }
        int main(void) {
            printf("%d\n", process("10 + 20")(10,20));
            return 0;
        }</code></pre>
    - <pre><code>int add(int a, int b) {
        return a + b;
        }
        int(*process(char* a))(int, int) {
            printf("%s\n", a);
            return add;
        }
        int main(void) {
            int(*fp)(int, int) = add;
            printf("%d\n", fp(10,3));
            return 0;
        }</code></pre>
    - 자주 사용되지는 않음.

## Class16

- 하나의 구조체 변수만 사용하는 경우 정의와 동시에 선언을 할 수도 있음. 이 경우 변수는 전역 변수로 사용됨.
- 익명 구조체의 개념이 있어서, 구조체의 이름 부분을 비워 놓아도 됨.
- ```typedef```를 이용해서 임의의 자료형을 만들 수 있음. 선언이 더 짧아짐.
- 구조체가 포인터 변수로 사용되는 경우 내부 변수에 접근할 때 ```->```을 사용함.

## Class17

- 파일 입출력 :
    - <pre><code>FILE *fp;
        fp = fopen(경로, 접근방식);
        //파일처리
        fclose(fp);</code></pre>

## Class18

- 전처리기
    - 전처리기 구문은 다른 프로그램 영역과 독립적으로 처리됨.
    - 전처리기 구문은 소스코드 파일 단위로 효력이 존재함.
    - 파일포함 전처리기 : ```#include <파일이름>```, ```#include "파일이름"```
    - 매크로 전처리기 : ```#define```
    - 조건부 컴파일 : ```#ifndef ~ #endif```
    - 파일 분할 컴파일

## Class19

- Time Complexity : 알고리즘에 사용되는 연산 횟수
- Space Complexity : 알고리즘에 사용되는 메모리의 양

## Class20

- 배열 기반 리스트
    - 특정 위치에 즉시 접근가능한 장점
    - 공간을 미리 메모리에 할당해야 하는 단점
    - 특정 위치로의 삽입이나 삭제가 비효적
- 연결 리스트
    - 구조체와 포인터로 구현
    - 필요할 때마다 메모리 공간을 동적할당
    - 중간에 노드를 추가하거나 삭제 가능
    - 시작노드는 Head라고 하며 별도 관리함
    - 끝 노드의 다음 위치값은 NULL을 넣음
    - 특정 인덱스로 즉시 접근이 안됨
    - 추가적인 포인터 변수가 사용됨으로 메모리 공간을 소비함

## Class21

- 양방향 연결 리스트

## Class22

- stack

## Class23

- 